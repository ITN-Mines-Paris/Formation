---
title: Digital Research Projects
author: SÃ©bastien Boisgerault (@boisgera)
theme: uncover
size: 16:9
marp: true
---

# Digital Research Project

## Anatomy

--- 

## General Goal

  - Maximize the utility of your research (for you and others)

  - Here : share every component of value from your research

---

Leads:

1. identify all research products/artefacts and their nature
    (any potential holder of value)

2. split / decompose / untangle them (reductionist)

3. expose the links between them (source/causality analysis)

4. Share the project history

----

![bg](https://unsplash.com/photos/M-EwSRl8BK8/download?w=1600&auto=format)

# Expose all artifacts

<!--
Arctic Icebergs in Ilulissat, Greenland
https://unsplash.com/photos/photo-of-iceberg-M-EwSRl8BK8
Unsplash License

Instagram: www.instagram.com/mlenny/ 
Copyright by Mlenny Photography 
Blog : www.mlenny.com 
istockphoto.com/portfolio/mlenny
-->

----

![bg](https://unsplash.com/photos/dhL82KC11sY/download?w=1600&auto=true)

# Avoid Monoliths

----

## Nature of Artifacts

Let's use the software engineering linguo:
**Artifact** 
to refer to any 
**Digital Research Product**.

---

> By "artifact" we mean a digital object that was either created by the authors to be used as part of the study or generated by the experiment itself. 
> For example, artifacts can be software systems, scripts used to run experiments, input datasets, raw data collected in the experiment, or scripts used to analyze results. 

<https://dl.acm.org/artifacts/software>

---

  - Document
  - Data
  - Software

  - Metadata
  - Configuration
  - Build
  - ...

---

Definitions? Examples first, extract the definition from them.

Examples : some simple and some not so simple / blur the distinctions. 
Sometimes views rather then different kinds.

Why does the kind identif. matter? "Optimizations"/proper forms are type-specific.


--- 

# Artifacts Creation Process

Stuff creates stuff (with stuff).

Tree of dependencies first, source/target identification (guessing game ?)
(forget about the tooling itself at first, reproducibity is a big issue in itself)

---

 - Why the identification of sources matter, why distributes those instead of the targets?

 - Give all the sources (ex: source code to generate the graph of a document)

   Source of information / derived information.

 - Do intermediate artifacts need to be distributed (yes, sometimes!
   ML Weights, compiled software, etc.)

 - Task runners & stuff (Makefile, Taskfile, pixi, etc.)

---

  ## Exemples

  - LaTeX project? (.sty, .tex, .bib)
  - Pandoc project?
  - Typst project?
  - Small Python project? (Ex: toy ML project?)

---

# Reproducibility

Same inputs and tools $\to$ same outputs

Requires the tooling to be *unambiguously* 

---

TODO: versions & dependencies ; semantic versionning.

---

Supported versions vs "the one" (spec. vs lock)

---

TODO: pixi example?

---

# HISTORY

<!-- _color: white -->

![bg](https://unsplash.com/photos/5lpbC64r3Z4/download?ixid=M3wxMjA3fDB8MXxhbGx8fHx8fHx8fHwxNzM5Nzk5MTkxfA&force=true&w=1600)

---

TODO:
  - Why preserve project history,
  - Versions (semantic versionning)
  - Tree-structure of the past
  - Tools (Releases, git).
